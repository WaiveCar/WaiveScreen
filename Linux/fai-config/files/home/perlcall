#!/usr/bin/perl

use strict;
use warnings;
use Scalar::Util qw/reftype/;

sub install_list {
  my $ix = 0;
  open(my $fh, '<:encoding(UTF-8)', '/home/adorno/WaiveScreen/Linux/fai-config/package_config/DEBIAN') or die '';

  my @all = qw//;
  while (my $row = <$fh>) {
    chomp $row;

    # Remove comments
    $row =~ s/#.*//ig;

    # Skip empty lines
    next if $row =~ /^$/;

    # Only use the first set
    if ( $row =~ /^PACKAGES/ ) {
      last if $ix++ == 1;

    } else {
      push(@all, split(/\s+/, $row));
    }
  }
  qx(sudo rm -f /tmp/to-install /tmp/already-installed);
  open(my $fhout, '>', '/tmp/to-install');
  print $fhout join "\n", sort(@all);
  close $fhout;
  qx(dpkg-query -l | grep '^ii'| awk '{ print \$2 }' | sort > /tmp/already-installed);
  return qx(comm -13 /tmp/already-installed /tmp/to-install);
}

sub capture_all_cameras {
  my @videoList = glob("/dev/video*");

  for(my $ix = 0; $ix < $#videoList; $ix += 2) {
    unlink "/tmp/video${ix}.mp4";
    qx(ffmpeg -i /dev/video$ix -an -t 5 -y /tmp/video${ix}.mp4 &);
  }
  sleep 8;

  my @outlist = glob("/tmp/video*.mp4");

  return $#outlist;
}

sub acceptance_screen {
  open(my $uuidFile, '<:encoding(UTF-8)', '/etc/UUID') or die '';
  my $uuid = <$uuidFile>;
  close($uuidFile);

  open(my $html, '>', '/tmp/acceptance.html');
  print $html qq(<style>
.bad,.good,.value {
  color:rgb(170,64,64);
  font-weight: bold;
  margin-left:.5rem
}
.value { color:rgb(64,64,64);margin-left:3rem }
.good { color:rgb(64,170,64); }
.good:before,.bad:before {
  content: '\\2714';
  font-size: 2.5rem;
  margin-right:0.25rem;
  vertical-align: sub;
}
.bad:before { content: '\\2717'; }
</style>
<body style="text-align:center;padding:2rem;background:url('data:image/gif;base64,R0lGODlhAgACAPAAAAkJCf///yH+EUNyZWF0ZWQgd2l0aCBHSU1QACwAAAAAAgACAAACAwwQBQA7') repeat">
<span style=padding:1rem;display:inline-block;background:rgba(255,255,255,0.9);font-family:sans-serif;font-size:1.5rem;min-width:20rem;text-align:left>
<div style=padding-bottom:.5rem><b>$uuid</b><div style=font-size:.8rem;font-weight:bold><script>document.write(new Date());</script></div></div>
  );

  my @features = detect_features();
  my @top = ();
  my @bottom = ();
  for (my $ix = 0; $ix < scalar @features; $ix += 2) {
    my $key = $features[$ix];
    my $value = $features[$ix + 1];
    if (!$value || $value <= 1) {
      my $class = $value ? 'good' : 'bad';
      push @top, "<div class=$class>$key</div>";
    } else {
      push @bottom, "<div class=value>$key: $value</div>";
    }
  }
  print $html join "\n", @top;
  print $html join "\n", @bottom;

  print $html qq(<div style=font-style:italic;padding-top:1rem;font-size:1rem;text-align:center>press ctrl+w to exit</div>
</span>
</body>
  );
  close $html;
}

# see #73
sub detect_features {
  my @videoList = glob("/dev/video*");
  my $hasSim = qx(mmcli -m 0 --output-keyvalue | grep sim | grep org | wc -l);

  # * btle - todo
  my @features = (
    "modem", -e "/dev/cdc-wdm0" ? 1 : 0,
    "arduino", -e "/dev/ttyACM0" ? 1 : 0,
    "cameras", ($#videoList + 1) / 2,
    "ip", qx(mmcli -b 0| grep address | wc -l) > 0,
    "wifi", -e "/proc/sys/net/ipv4/conf/wlp1s0" ? 1 : 0,
    "sim", $hasSim
  );
  for (my $ix = 1; $ix < scalar @features; $ix += 2) {
    $features[$ix] =~ s/\s//g;
  }
  return @features;
}

sub acceptance_test {
  my %results = {
    # Make sure gps has actual lat/lng
    'gps' => qx(mmcli -m 0 --location-get --output-keyvalue | grep longitude | grep -v -- -- | wc -l),

    # Check to make sure we have access to sensors
    'sensor' => qx(pycall sensor_last | wc -c) > 200,

    # Make sure we can get online-- todo
    
    # Number of cameras/bus isolation
    'cameras' => capture_all_cameras
  };
}

if ($#ARGV >= 0) {
 my $res = eval "${ARGV[0]}()";
 if (ref $res eq ref {}) {
   print "hash";
 } else {
   print $res;
 }
}
