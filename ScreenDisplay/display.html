<style>
body {
  margin: 0;
  background: black; 
}
img { 
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}
@keyframes fadeOut {
  0% {opacity: 1;}
  100% {opacity: 0;} 
} 
@keyframes fadeIn {
  0% {opacity: 0;}
  100% {opacity: 1;} 
} 
.fadeOut {
  animation-name: fadeOut;
  animation-duration: 0.4s;
}
.fadeIn {
  animation-name: fadeIn;
  animation-duration: 0.4s;
}
</style>

<body></body>

<script>
var dbList = [],
  dbMap = {},
  log = [],
  startTime = new Date(),
  last = false,
  fallback,
  count = 0,
  duration = 15;

function image(what) {
  var img = document.createElement('img');
  img.src = "assets/" + what;
  return img;
}

// LRU cache invalidation should eventually exist.
function addJob(job) {
  if(!dbMap[job.campaign_id]) {

    // this acts as the instantiation. 
    // the merging of the rest of the data
    // will come below.
    dbMap[job.campaign_id] = {
      dom: image(job.asset),
    }

  }

  dbMap[job.campaign_id] = Object.merge(
    dbMap[job.campaign_id], job
  );

  return dbMap[job.campaign_id];
}

function post(url, what, cb) {
  var http = new XMLHttpRequest();

  http.open('POST', 'http://localhost:4096/' + url, true);

  http.setRequestHeader('Content-type', 'application/json');

  http.onreadystatechange = function() {
    if(http.readyState == 4 && http.status == 200) {
      cb(http.responseText);
    }
  }
  http.send(JSON.stringify(what));
}

function loop() {
  setInterval(function() {
    // We note something we call "breaks" which designate which asset to show.
    // This is a composite of what remains - this is two pass, eh, kill me.
    var total = dbList.reduce(function (a, b) { return a + b.commitment - b.satisfied }, 0);
    var breakpoint = Math.random() * total;
    var toShow, 
      accum = 0, 
      row, 
      prev = last;

    if(total <= 0 ) {
      toShow = fallback;
    } else {

      for(row of dbList) {
        accum += row.commitment - row.satisfied;
        if( accum > breakpoint ) {
          toShow = row;
          break;
        }
      }
      if(!toShow) {
        toShow = row;
      }
    }

    toShow.satisfied += 1;

    try {
      if(prev && (prev.what !== toShow.what)) {
        prev.dom.classList.add('fadeOut');
        setTimeout(function() {
          prev.dom.classList.remove('fadeOut');
          document.body.removeChild(prev.dom);
        }, 500);
      }
    } catch(ex) { console.log(ex)} 
    if(prev && (prev.what !== toShow.what)) {
      log.push([new Date(), toShow.what]);

      toShow.dom.classList.add('fadeIn');
      document.body.appendChild(toShow.dom);
    }
    last = toShow;
  }, 1200);
}

window.onload = function init() {
  fallback = {
    what: 'fallback.png',
    dom:  image('fallback.png'),
    satisfied: 0
  };
  loop();
}
</script>
