<style>
body {
  margin: 0;
  background: black; 
}
img { 
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}
@keyframes fadeOut {
  0% {opacity: 1;}
  100% {opacity: 0;} 
} 
@keyframes fadeIn {
  0% {opacity: 0;}
  100% {opacity: 1;} 
} 
.fadeOut {
  animation-name: fadeOut;
  animation-duration: 0.4s;
}
.fadeIn {
  animation-name: fadeIn;
  animation-duration: 0.4s;
}
</style>

<body></body>

<script>
// a global pointer to the current job object.
var CURRENT;

var dbMap = {},
  startTime = new Date(),
  last = false,
  fallback,
  duration = 12;

// The job schema coming in, copied from the python lib/db.py code:
//
//  ('id', 'integer primary key autoincrement'),
//  ('campaign_id', 'integer'),
//  ('goal', 'integer'),
//  ('completion_seconds', 'integer default 0'),
//  ('last_update', 'datetime default current_timestamp'),
//  ('job_start',  'datetime'),
//  ('job_end', 'datetime')

function image(what) {
  var img = document.createElement('img');
  img.onerror = function() {
    this.src = fallback.url;
    CURRENT.err = 'NOT_FOUND';
  }
  img.onload = function() {
    if('err' in CURRENT) {
      delete CURRENT.err;
    }
  }
  img.src = what;
  img.src_ = what;
  return img;
}

// LRU cache invalidation should eventually exist.
function addJob(job) {
  if(!dbMap[job.campaign_id]) {

    // this acts as the instantiation. 
    // the merging of the rest of the data
    // will come below.
    dbMap[job.campaign_id] = {
      dom: image(job.asset),
      done: 0,
    };
  }

  dbMap[job.campaign_id] = Object.merge(
    dbMap[job.campaign_id], job
  );

  return dbMap[job.campaign_id];
}

function post(url, what, cb) {
  var http = new XMLHttpRequest();

  http.open('POST', 'http://localhost:4096/' + url, true);
  http.setRequestHeader('Content-type', 'application/json');

  http.onreadystatechange = function() {
    if(http.readyState == 4 && http.status == 200) {
      cb(http.responseText);
    }
  }
  
  http.send(JSON.stringify(what));
}

function loop() {
  setInterval(function() {
    // We note something we call "breaks" which designate which asset to show.
    // This is a composite of what remains - this is two pass, eh, kill me.
    var total = Object.values(dbMap).reduce(function (a, b) { return a + b.goal - b.done }, 0),
      breakpoint = Math.random() * total,
      toShow, 
      accum = 0, 
      row, 
      prev = last;

    if(total <= 0 ) {
      toShow = fallback;
    } else {

      for(key in dbMap) {
        row = dbMap[key];

        accum += row.goal - row.done;
        if(accum > breakpoint) {
          toShow = row;
          break;
        }
      }
      if(!toShow) {
        toShow = row;
      }
    }

    CURRENT = toShow;

    toShow.done += duration;

    try {
      if(prev && (prev.what !== toShow.what)) {
        prev.dom.classList.add('fadeOut');
        setTimeout(function() {
          prev.dom.classList.remove('fadeOut');
          document.body.removeChild(prev.dom);
        }, 500);
      }
    } catch(ex) { console.log(ex)} 
    if(prev && (prev.what !== toShow.what)) {

      toShow.dom.classList.add('fadeIn');
      document.body.appendChild(toShow.dom);
    }
    last = toShow;
  }, duration * 1000);
}

window.onload = function init() {
  fallback = {
    what: 'fallback.png',
    dom:  image('fallback.png'),
    done: 0
  };
  loop();
}
</script>
